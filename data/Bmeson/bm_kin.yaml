selection:
  ### (keep your existing logic)

new_variables:
  part_mask: ak.ones_like(part_px)
  part_pt: np.hypot(part_px, part_py)
  part_eta: np.arcsinh(part_pz / np.maximum(part_pt, 1e-8))
  part_phi: np.arctan2(part_py, part_px)
  # part_ptrel: part_pt / jet_pt
  part_deltaR: np.hypot(part_eta, part_phi)
  # part_logptrel: np.log(np.maximum(part_ptrel, 1e-8))
  # jet_pt: ak.sum(part_pt, axis=1)
  # jet_energy: ak.sum(part_energy, axis=1)
  is_B: label
  is_not: 1 - label

preprocess:
  method: auto
  data_fraction: 0.9

inputs:
  pf_points:
    length: 128
    pad_mode: constant
    pad_value: 0.0
    vars: 
      - [part_px, null]
      - [part_py, null]
  
  pf_features:
    length: 128
    pad_mode: constant
    pad_value: 0.0
    vars: 
      - [part_pt, null]
      - [part_eta, null]
      - [part_phi, null]
      # - [part_ptrel, null]
      - [part_deltaR, null]
      # - [part_logptrel, null]
      - [part_mass, null]
      - [part_pdgid, null]
  
  pf_vectors:
    length: 128
    pad_mode: constant
    pad_value: 0.0
    vars: 
      - [part_px, null]
      - [part_py, null]
      - [part_pz, null]
      - [part_energy, null]
  
  pf_mask:
    length: 128
    pad_mode: constant
    pad_value: 0.0
    vars: 
      - [part_mask, null]
  
  # event_features:
  #   length: 1
  #   pad_mode: constant
  #   pad_value: 0.0
  #   vars:
  #     - [thrust]
  #     - [sphericity]
  #     - [aplanarity]
  #     - [jet_pt]
  #     - [jet_energy]

labels:
  type: simple
  value: [is_B, is_not]

observers:
  - part_energy
  - part_mass

weights:
#   weight: np.where(is_B > 0.5, 3.0, 1.0)  # Adjust ratio based on imbalance